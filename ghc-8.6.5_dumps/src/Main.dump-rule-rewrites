Rule fired
    Rule: SPEC $fShow[]
    Module: (GHC.Show)
    Before: GHC.Show.$fShow[]
              TyArg GHC.Types.Char ValArg GHC.Show.$fShowChar
    After:  (\ ($dShow_a7TH :: GHC.Show.Show GHC.Types.Char) ->
               GHC.Show.$fShow[]_$s$fShow[]1)
              GHC.Show.$fShowChar
    Cont:   Stop[RhsCtxt] GHC.Show.Show [GHC.Types.Char]
Rule fired
    Rule: Class op >>=
    Module: (BUILTIN)
    Before: GHC.Base.>>= TyArg GHC.Types.IO ValArg GHC.Base.$fMonadIO
    After:  GHC.Base.$fMonadIO1
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <GHC.Types.IO a>_R
                    ->_R <a -> GHC.Types.IO b>_R
                    ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                    :: (forall a b.
                        GHC.Types.IO a
                        -> (a -> GHC.Types.IO b)
                        -> GHC.Prim.State# GHC.Prim.RealWorld
                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #))
                       ~R# (forall a b.
                            GHC.Types.IO a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b))
    Cont:   ApplyToTy GHC.Integer.Type.Integer
            ApplyToTy ()
            ApplyToVal nodup System.CPUTime.getCPUTime
            ApplyToVal nodup (\ (start_a1UD [Occ=OnceL]
                                   :: GHC.Integer.Type.Integer) ->
                                GHC.Base.>>=
                                  @ GHC.Types.IO
                                  GHC.Base.$fMonadIO
                                  @ GHC.Integer.Type.Integer
                                  @ ()
                                  (Control.DeepSeq.deepseq
                                     @ a_a5KA
                                     @ (GHC.Types.IO GHC.Integer.Type.Integer)
                                     $dNFData_a5KC
                                     f_a1UC
                                     System.CPUTime.getCPUTime)
                                  (\ (end_a1UF [Occ=Once] :: GHC.Integer.Type.Integer) ->
                                     let {
                                       duration_a1UG :: GHC.Integer.Type.Integer
                                       [LclId]
                                       duration_a1UG
                                         = GHC.Num.-
                                             @ GHC.Integer.Type.Integer
                                             GHC.Num.$fNumInteger
                                             end_a1UF
                                             start_a1UD } in
                                     GHC.Base.$
                                       @ 'GHC.Types.LiftedRep
                                       @ [GHC.Types.Char]
                                       @ (GHC.Types.IO ())
                                       (System.IO.print @ [GHC.Types.Char] $dShow_a5Mb)
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          description_a1UB
                                          (GHC.Base.++
                                             @ GHC.Types.Char
                                             (GHC.Show.show
                                                @ GHC.Integer.Type.Integer
                                                GHC.Show.$fShowInteger
                                                (GHC.Real.div
                                                   @ GHC.Integer.Type.Integer
                                                   GHC.Real.$fIntegralInteger
                                                   duration_a1UG
                                                   1000000000))
                                             (GHC.Base.++
                                                @ GHC.Types.Char
                                                (GHC.CString.unpackCString# " milli seconds -- "#)
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   (GHC.Show.show
                                                      @ GHC.Integer.Type.Integer
                                                      GHC.Show.$fShowInteger
                                                      duration_a1UG)
                                                   (GHC.CString.unpackCString#
                                                      " pico seconds"#)))))))
            Stop[BoringCtxt] GHC.Types.IO ()
Rule fired
    Rule: Class op >>=
    Module: (BUILTIN)
    Before: GHC.Base.>>= TyArg GHC.Types.IO ValArg GHC.Base.$fMonadIO
    After:  GHC.Base.$fMonadIO1
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <GHC.Types.IO a>_R
                    ->_R <a -> GHC.Types.IO b>_R
                    ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                    :: (forall a b.
                        GHC.Types.IO a
                        -> (a -> GHC.Types.IO b)
                        -> GHC.Prim.State# GHC.Prim.RealWorld
                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #))
                       ~R# (forall a b.
                            GHC.Types.IO a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b))
    Cont:   ApplyToTy GHC.Integer.Type.Integer
            ApplyToTy ()
            ApplyToVal nodup (Control.DeepSeq.deepseq
                                @ a_a5KA
                                @ (GHC.Types.IO GHC.Integer.Type.Integer)
                                $dNFData_a5KC
                                f_a1UC
                                System.CPUTime.getCPUTime)
            ApplyToVal nodup (\ (end_a1UF [Occ=Once]
                                   :: GHC.Integer.Type.Integer) ->
                                let {
                                  duration_a1UG :: GHC.Integer.Type.Integer
                                  [LclId]
                                  duration_a1UG
                                    = GHC.Num.-
                                        @ GHC.Integer.Type.Integer
                                        GHC.Num.$fNumInteger
                                        end_a1UF
                                        start_a1UD } in
                                GHC.Base.$
                                  @ 'GHC.Types.LiftedRep
                                  @ [GHC.Types.Char]
                                  @ (GHC.Types.IO ())
                                  (System.IO.print @ [GHC.Types.Char] $dShow_a5Mb)
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     description_a1UB
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (GHC.Show.show
                                           @ GHC.Integer.Type.Integer
                                           GHC.Show.$fShowInteger
                                           (GHC.Real.div
                                              @ GHC.Integer.Type.Integer
                                              GHC.Real.$fIntegralInteger
                                              duration_a1UG
                                              1000000000))
                                        (GHC.Base.++
                                           @ GHC.Types.Char
                                           (GHC.CString.unpackCString# " milli seconds -- "#)
                                           (GHC.Base.++
                                              @ GHC.Types.Char
                                              (GHC.Show.show
                                                 @ GHC.Integer.Type.Integer
                                                 GHC.Show.$fShowInteger
                                                 duration_a1UG)
                                              (GHC.CString.unpackCString# " pico seconds"#))))))
            CastIt (GHC.Types.N:IO[0] <()>_R
                    :: GHC.Types.IO ()
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)))
            ApplyToVal nodup ipv_a7Ue
            Stop[BoringCtxt] (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
Rule fired
    Rule: Class op -
    Module: (BUILTIN)
    Before: GHC.Num.-
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Integer.Type.minusInteger
    Cont:   ApplyToVal nodup end_a1UF
            ApplyToVal nodup start_a1UD
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShow[]_$s$fShow[]1
    After:  GHC.Show.$fShow[]_$s$cshow1
    Cont:   ApplyToVal nodup x_a7Dp
            Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg GHC.Integer.Type.Integer ValArg GHC.Show.$fShowInteger
    After:  GHC.Show.$fShowInteger_$cshow
    Cont:   ApplyToVal nodup (GHC.Real.div
                                @ GHC.Integer.Type.Integer
                                GHC.Real.$fIntegralInteger
                                duration_a1UG
                                1000000000)
            Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: Class op div
    Module: (BUILTIN)
    Before: GHC.Real.div
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fIntegralInteger_$cdiv
    Cont:   ApplyToVal nodup duration_a1UG
            ApplyToVal nodup 1000000000
            Stop[RuleArgCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: eqInteger#
    Module: (BUILTIN)
    Before: GHC.Integer.Type.eqInteger# ValArg ds1_a7VA ValArg 0
    After:  0#
    Cont:   Select nodup wild_a7VB
            Stop[RuleArgCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg " milli seconds -- "#
    After:  (\ (a_a7VD :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) -> GHC.CString.unpackFoldrCString# @ b_a7VH a_a7VD))
              " milli seconds -- "#
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg GHC.Integer.Type.Integer ValArg GHC.Show.$fShowInteger
    After:  GHC.Show.$fShowInteger_$cshow
    Cont:   ApplyToVal nodup duration_a1UG
            Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg " pico seconds"#
    After:  (\ (a_a7VD :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) -> GHC.CString.unpackFoldrCString# @ b_a7VH a_a7VD))
              " pico seconds"#
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: ++
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Show.$fShowInteger_$cshowsPrec
                       GHC.Show.$fShow(,)1 duration_a1UG (GHC.Types.[] @ GHC.Types.Char)
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7VH) ->
                          GHC.CString.unpackFoldrCString# @ b_a7VH " pico seconds"#)
    After:  (\ (@ a_a7UY)
               (xs_a7UZ :: [a_a7UY])
               (ys_a7V0 :: [a_a7UY]) ->
               GHC.Base.augment
                 @ a_a7UY
                 (\ (@ b_a7V4)
                    (c_a7V5 [Occ=Once, OS=OneShot] :: a_a7UY -> b_a7V4 -> b_a7V4)
                    (n_a7V6 [Occ=Once, OS=OneShot] :: b_a7V4) ->
                    GHC.Base.foldr @ a_a7UY @ b_a7V4 c_a7V5 n_a7V6 xs_a7UZ)
                 ys_a7V0)
              @ GHC.Types.Char
              (GHC.Show.$fShowInteger_$cshowsPrec
                 GHC.Show.$fShow(,)1 duration_a1UG (GHC.Types.[] @ GHC.Types.Char))
              (GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) ->
                    GHC.CString.unpackFoldrCString# @ b_a7VH " pico seconds"#))
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: augment/build
    Module: (GHC.Base)
    Before: GHC.Base.augment
              TyArg GHC.Types.Char
              ValArg \ (@ b_a7V4)
                       (c_a7V5 [OS=OneShot] :: GHC.Types.Char -> b_a7V4 -> b_a7V4)
                       (n_a7V6 [OS=OneShot] :: b_a7V4) ->
                       GHC.Base.foldr
                         @ GHC.Types.Char
                         @ b_a7V4
                         c_a7V5
                         n_a7V6
                         (GHC.Show.$fShowInteger_$cshowsPrec
                            GHC.Show.$fShow(,)1 duration_a1UG (GHC.Types.[] @ GHC.Types.Char))
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7VH) ->
                          GHC.CString.unpackFoldrCString# @ b_a7VH " pico seconds"#)
    After:  (\ (@ a_a7VW)
               (g_a7VX :: forall b. (a_a7VW -> b -> b) -> b -> b)
               (h_a7VZ :: forall b. (a_a7VW -> b -> b) -> b -> b) ->
               GHC.Base.build
                 @ a_a7VW
                 (\ (@ b_a7W1)
                    (c_a7W2 [OS=OneShot] :: a_a7VW -> b_a7W1 -> b_a7W1)
                    (n_a7W3 [Occ=Once, OS=OneShot] :: b_a7W1) ->
                    g_a7VX @ b_a7W1 c_a7W2 (h_a7VZ @ b_a7W1 c_a7W2 n_a7W3)))
              @ GHC.Types.Char
              (\ (@ b_a7V4)
                 (c_a7V5 [OS=OneShot] :: GHC.Types.Char -> b_a7V4 -> b_a7V4)
                 (n_a7V6 [OS=OneShot] :: b_a7V4) ->
                 GHC.Base.foldr
                   @ GHC.Types.Char
                   @ b_a7V4
                   c_a7V5
                   n_a7V6
                   (GHC.Show.$fShowInteger_$cshowsPrec
                      GHC.Show.$fShow(,)1 duration_a1UG (GHC.Types.[] @ GHC.Types.Char)))
              (\ (@ b_a7VH) ->
                 GHC.CString.unpackFoldrCString# @ b_a7VH " pico seconds"#)
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: ++
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7VH) ->
                          GHC.CString.unpackFoldrCString# @ b_a7VH " milli seconds -- "#)
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7W1)
                          (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                          (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                          GHC.Base.foldr
                            @ GHC.Types.Char
                            @ b_a7W1
                            c_a7W2
                            (GHC.CString.unpackFoldrCString#
                               @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                            (GHC.Show.$fShowInteger_$cshowsPrec
                               GHC.Show.$fShow(,)1 duration_a1UG (GHC.Types.[] @ GHC.Types.Char)))
    After:  (\ (@ a_a7UY)
               (xs_a7UZ :: [a_a7UY])
               (ys_a7V0 :: [a_a7UY]) ->
               GHC.Base.augment
                 @ a_a7UY
                 (\ (@ b_a7V4)
                    (c_a7V5 [Occ=Once, OS=OneShot] :: a_a7UY -> b_a7V4 -> b_a7V4)
                    (n_a7V6 [Occ=Once, OS=OneShot] :: b_a7V4) ->
                    GHC.Base.foldr @ a_a7UY @ b_a7V4 c_a7V5 n_a7V6 xs_a7UZ)
                 ys_a7V0)
              @ GHC.Types.Char
              (GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) ->
                    GHC.CString.unpackFoldrCString# @ b_a7VH " milli seconds -- "#))
              (GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7W1)
                    (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                    (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b_a7W1
                      c_a7W2
                      (GHC.CString.unpackFoldrCString#
                         @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                      (GHC.Show.$fShowInteger_$cshowsPrec
                         GHC.Show.$fShow(,)1
                         duration_a1UG
                         (GHC.Types.[] @ GHC.Types.Char))))
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: fold/build
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg b_a7V4
              ValArg c_a7V5
              ValArg n_a7V6
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7VH) ->
                          GHC.CString.unpackFoldrCString# @ b_a7VH " milli seconds -- "#)
    After:  (\ (@ b_a7WS)
               (@ a_a7WT)
               (k_a7WU :: a_a7WT -> b_a7WS -> b_a7WS)
               (z_a7WV :: b_a7WS)
               (g_a7WW :: forall b1. (a_a7WT -> b1 -> b1) -> b1 -> b1) ->
               g_a7WW @ b_a7WS k_a7WU z_a7WV)
              @ b_a7V4
              @ GHC.Types.Char
              c_a7V5
              n_a7V6
              (\ (@ b_a7VH) ->
                 GHC.CString.unpackFoldrCString# @ b_a7VH " milli seconds -- "#)
    Cont:   Stop[BoringCtxt] b_a7V4
Rule fired
    Rule: augment/build
    Module: (GHC.Base)
    Before: GHC.Base.augment
              TyArg GHC.Types.Char
              ValArg \ (@ b_a7V4)
                       (c_a7V5 [OS=OneShot] :: GHC.Types.Char -> b_a7V4 -> b_a7V4)
                       (n_a7V6 [OS=OneShot] :: b_a7V4) ->
                       GHC.CString.unpackFoldrCString#
                         @ b_a7V4 " milli seconds -- "# c_a7V5 n_a7V6
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7W1)
                          (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                          (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                          GHC.Base.foldr
                            @ GHC.Types.Char
                            @ b_a7W1
                            c_a7W2
                            (GHC.CString.unpackFoldrCString#
                               @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                            (GHC.Show.$fShowInteger_$cshowsPrec
                               GHC.Show.$fShow(,)1 duration_a1UG (GHC.Types.[] @ GHC.Types.Char)))
    After:  (\ (@ a_a7VW)
               (g_a7VX :: forall b. (a_a7VW -> b -> b) -> b -> b)
               (h_a7VZ :: forall b. (a_a7VW -> b -> b) -> b -> b) ->
               GHC.Base.build
                 @ a_a7VW
                 (\ (@ b_a7W1)
                    (c_a7W2 [OS=OneShot] :: a_a7VW -> b_a7W1 -> b_a7W1)
                    (n_a7W3 [Occ=Once, OS=OneShot] :: b_a7W1) ->
                    g_a7VX @ b_a7W1 c_a7W2 (h_a7VZ @ b_a7W1 c_a7W2 n_a7W3)))
              @ GHC.Types.Char
              (\ (@ b_a7V4)
                 (c_a7V5 [OS=OneShot] :: GHC.Types.Char -> b_a7V4 -> b_a7V4)
                 (n_a7V6 [OS=OneShot] :: b_a7V4) ->
                 GHC.CString.unpackFoldrCString#
                   @ b_a7V4 " milli seconds -- "# c_a7V5 n_a7V6)
              (\ (@ b_a7W1)
                 (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                 (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                 GHC.Base.foldr
                   @ GHC.Types.Char
                   @ b_a7W1
                   c_a7W2
                   (GHC.CString.unpackFoldrCString#
                      @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                   (GHC.Show.$fShowInteger_$cshowsPrec
                      GHC.Show.$fShow(,)1 duration_a1UG (GHC.Types.[] @ GHC.Types.Char)))
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: ++
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Show.$fShowInteger_$cshowsPrec
                       GHC.Show.$fShow(,)1
                       (let {
                          ds1_a7VA :: GHC.Integer.Type.Integer
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                                   WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
                          ds1_a7VA = 1000000000 } in
                        GHC.Integer.Type.divInteger duration_a1UG ds1_a7VA)
                       (GHC.Types.[] @ GHC.Types.Char)
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7W1)
                          (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                          (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                          GHC.CString.unpackFoldrCString#
                            @ b_a7W1
                            " milli seconds -- "#
                            c_a7W2
                            (GHC.Base.foldr
                               @ GHC.Types.Char
                               @ b_a7W1
                               c_a7W2
                               (GHC.CString.unpackFoldrCString#
                                  @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                               (GHC.Show.$fShowInteger_$cshowsPrec
                                  GHC.Show.$fShow(,)1
                                  duration_a1UG
                                  (GHC.Types.[] @ GHC.Types.Char))))
    After:  (\ (@ a_a7UY)
               (xs_a7UZ :: [a_a7UY])
               (ys_a7V0 :: [a_a7UY]) ->
               GHC.Base.augment
                 @ a_a7UY
                 (\ (@ b_a7V4)
                    (c_a7V5 [Occ=Once, OS=OneShot] :: a_a7UY -> b_a7V4 -> b_a7V4)
                    (n_a7V6 [Occ=Once, OS=OneShot] :: b_a7V4) ->
                    GHC.Base.foldr @ a_a7UY @ b_a7V4 c_a7V5 n_a7V6 xs_a7UZ)
                 ys_a7V0)
              @ GHC.Types.Char
              (GHC.Show.$fShowInteger_$cshowsPrec
                 GHC.Show.$fShow(,)1
                 (let {
                    ds1_a7VA :: GHC.Integer.Type.Integer
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                             WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
                    ds1_a7VA = 1000000000 } in
                  GHC.Integer.Type.divInteger duration_a1UG ds1_a7VA)
                 (GHC.Types.[] @ GHC.Types.Char))
              (GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7W1)
                    (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                    (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                    GHC.CString.unpackFoldrCString#
                      @ b_a7W1
                      " milli seconds -- "#
                      c_a7W2
                      (GHC.Base.foldr
                         @ GHC.Types.Char
                         @ b_a7W1
                         c_a7W2
                         (GHC.CString.unpackFoldrCString#
                            @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                         (GHC.Show.$fShowInteger_$cshowsPrec
                            GHC.Show.$fShow(,)1
                            duration_a1UG
                            (GHC.Types.[] @ GHC.Types.Char)))))
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: augment/build
    Module: (GHC.Base)
    Before: GHC.Base.augment
              TyArg GHC.Types.Char
              ValArg \ (@ b_a7V4)
                       (c_a7V5 [OS=OneShot] :: GHC.Types.Char -> b_a7V4 -> b_a7V4)
                       (n_a7V6 [OS=OneShot] :: b_a7V4) ->
                       GHC.Base.foldr
                         @ GHC.Types.Char
                         @ b_a7V4
                         c_a7V5
                         n_a7V6
                         (GHC.Show.$fShowInteger_$cshowsPrec
                            GHC.Show.$fShow(,)1
                            (GHC.Integer.Type.divInteger duration_a1UG 1000000000)
                            (GHC.Types.[] @ GHC.Types.Char))
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7W1)
                          (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                          (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                          GHC.CString.unpackFoldrCString#
                            @ b_a7W1
                            " milli seconds -- "#
                            c_a7W2
                            (GHC.Base.foldr
                               @ GHC.Types.Char
                               @ b_a7W1
                               c_a7W2
                               (GHC.CString.unpackFoldrCString#
                                  @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                               (GHC.Show.$fShowInteger_$cshowsPrec
                                  GHC.Show.$fShow(,)1
                                  duration_a1UG
                                  (GHC.Types.[] @ GHC.Types.Char))))
    After:  (\ (@ a_a7VW)
               (g_a7VX :: forall b. (a_a7VW -> b -> b) -> b -> b)
               (h_a7VZ :: forall b. (a_a7VW -> b -> b) -> b -> b) ->
               GHC.Base.build
                 @ a_a7VW
                 (\ (@ b_a7W1)
                    (c_a7W2 [OS=OneShot] :: a_a7VW -> b_a7W1 -> b_a7W1)
                    (n_a7W3 [Occ=Once, OS=OneShot] :: b_a7W1) ->
                    g_a7VX @ b_a7W1 c_a7W2 (h_a7VZ @ b_a7W1 c_a7W2 n_a7W3)))
              @ GHC.Types.Char
              (\ (@ b_a7V4)
                 (c_a7V5 [OS=OneShot] :: GHC.Types.Char -> b_a7V4 -> b_a7V4)
                 (n_a7V6 [OS=OneShot] :: b_a7V4) ->
                 GHC.Base.foldr
                   @ GHC.Types.Char
                   @ b_a7V4
                   c_a7V5
                   n_a7V6
                   (GHC.Show.$fShowInteger_$cshowsPrec
                      GHC.Show.$fShow(,)1
                      (GHC.Integer.Type.divInteger duration_a1UG 1000000000)
                      (GHC.Types.[] @ GHC.Types.Char)))
              (\ (@ b_a7W1)
                 (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                 (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                 GHC.CString.unpackFoldrCString#
                   @ b_a7W1
                   " milli seconds -- "#
                   c_a7W2
                   (GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b_a7W1
                      c_a7W2
                      (GHC.CString.unpackFoldrCString#
                         @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                      (GHC.Show.$fShowInteger_$cshowsPrec
                         GHC.Show.$fShow(,)1
                         duration_a1UG
                         (GHC.Types.[] @ GHC.Types.Char))))
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: ++
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg description_a1UB
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7W1)
                          (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                          (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                          GHC.Base.foldr
                            @ GHC.Types.Char
                            @ b_a7W1
                            c_a7W2
                            (GHC.CString.unpackFoldrCString#
                               @ b_a7W1
                               " milli seconds -- "#
                               c_a7W2
                               (GHC.Base.foldr
                                  @ GHC.Types.Char
                                  @ b_a7W1
                                  c_a7W2
                                  (GHC.CString.unpackFoldrCString#
                                     @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                                  (GHC.Show.$fShowInteger_$cshowsPrec
                                     GHC.Show.$fShow(,)1
                                     duration_a1UG
                                     (GHC.Types.[] @ GHC.Types.Char))))
                            (GHC.Show.$fShowInteger_$cshowsPrec
                               GHC.Show.$fShow(,)1
                               (GHC.Integer.Type.divInteger duration_a1UG 1000000000)
                               (GHC.Types.[] @ GHC.Types.Char)))
    After:  (\ (@ a_a7UY)
               (xs_a7UZ :: [a_a7UY])
               (ys_a7V0 :: [a_a7UY]) ->
               GHC.Base.augment
                 @ a_a7UY
                 (\ (@ b_a7V4)
                    (c_a7V5 [Occ=Once, OS=OneShot] :: a_a7UY -> b_a7V4 -> b_a7V4)
                    (n_a7V6 [Occ=Once, OS=OneShot] :: b_a7V4) ->
                    GHC.Base.foldr @ a_a7UY @ b_a7V4 c_a7V5 n_a7V6 xs_a7UZ)
                 ys_a7V0)
              @ GHC.Types.Char
              description_a1UB
              (GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7W1)
                    (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                    (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b_a7W1
                      c_a7W2
                      (GHC.CString.unpackFoldrCString#
                         @ b_a7W1
                         " milli seconds -- "#
                         c_a7W2
                         (GHC.Base.foldr
                            @ GHC.Types.Char
                            @ b_a7W1
                            c_a7W2
                            (GHC.CString.unpackFoldrCString#
                               @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                            (GHC.Show.$fShowInteger_$cshowsPrec
                               GHC.Show.$fShow(,)1
                               duration_a1UG
                               (GHC.Types.[] @ GHC.Types.Char))))
                      (GHC.Show.$fShowInteger_$cshowsPrec
                         GHC.Show.$fShow(,)1
                         (GHC.Integer.Type.divInteger duration_a1UG 1000000000)
                         (GHC.Types.[] @ GHC.Types.Char))))
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: augment/build
    Module: (GHC.Base)
    Before: GHC.Base.augment
              TyArg GHC.Types.Char
              ValArg \ (@ b_a7V4)
                       (c_a7V5 [OS=OneShot] :: GHC.Types.Char -> b_a7V4 -> b_a7V4)
                       (n_a7V6 [OS=OneShot] :: b_a7V4) ->
                       GHC.Base.foldr
                         @ GHC.Types.Char @ b_a7V4 c_a7V5 n_a7V6 description_a1UB
              ValArg GHC.Base.build
                       @ GHC.Types.Char
                       (\ (@ b_a7W1)
                          (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                          (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                          GHC.Base.foldr
                            @ GHC.Types.Char
                            @ b_a7W1
                            c_a7W2
                            (GHC.CString.unpackFoldrCString#
                               @ b_a7W1
                               " milli seconds -- "#
                               c_a7W2
                               (GHC.Base.foldr
                                  @ GHC.Types.Char
                                  @ b_a7W1
                                  c_a7W2
                                  (GHC.CString.unpackFoldrCString#
                                     @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                                  (GHC.Show.$fShowInteger_$cshowsPrec
                                     GHC.Show.$fShow(,)1
                                     duration_a1UG
                                     (GHC.Types.[] @ GHC.Types.Char))))
                            (GHC.Show.$fShowInteger_$cshowsPrec
                               GHC.Show.$fShow(,)1
                               (GHC.Integer.Type.divInteger duration_a1UG 1000000000)
                               (GHC.Types.[] @ GHC.Types.Char)))
    After:  (\ (@ a_a7VW)
               (g_a7VX :: forall b. (a_a7VW -> b -> b) -> b -> b)
               (h_a7VZ :: forall b. (a_a7VW -> b -> b) -> b -> b) ->
               GHC.Base.build
                 @ a_a7VW
                 (\ (@ b_a7W1)
                    (c_a7W2 [OS=OneShot] :: a_a7VW -> b_a7W1 -> b_a7W1)
                    (n_a7W3 [Occ=Once, OS=OneShot] :: b_a7W1) ->
                    g_a7VX @ b_a7W1 c_a7W2 (h_a7VZ @ b_a7W1 c_a7W2 n_a7W3)))
              @ GHC.Types.Char
              (\ (@ b_a7V4)
                 (c_a7V5 [OS=OneShot] :: GHC.Types.Char -> b_a7V4 -> b_a7V4)
                 (n_a7V6 [OS=OneShot] :: b_a7V4) ->
                 GHC.Base.foldr
                   @ GHC.Types.Char @ b_a7V4 c_a7V5 n_a7V6 description_a1UB)
              (\ (@ b_a7W1)
                 (c_a7W2 [OS=OneShot] :: GHC.Types.Char -> b_a7W1 -> b_a7W1)
                 (n_a7W3 [OS=OneShot] :: b_a7W1) ->
                 GHC.Base.foldr
                   @ GHC.Types.Char
                   @ b_a7W1
                   c_a7W2
                   (GHC.CString.unpackFoldrCString#
                      @ b_a7W1
                      " milli seconds -- "#
                      c_a7W2
                      (GHC.Base.foldr
                         @ GHC.Types.Char
                         @ b_a7W1
                         c_a7W2
                         (GHC.CString.unpackFoldrCString#
                            @ b_a7W1 " pico seconds"# c_a7W2 n_a7W3)
                         (GHC.Show.$fShowInteger_$cshowsPrec
                            GHC.Show.$fShow(,)1
                            duration_a1UG
                            (GHC.Types.[] @ GHC.Types.Char))))
                   (GHC.Show.$fShowInteger_$cshowsPrec
                      GHC.Show.$fShow(,)1
                      (GHC.Integer.Type.divInteger duration_a1UG 1000000000)
                      (GHC.Types.[] @ GHC.Types.Char)))
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op stimes
    Module: (BUILTIN)
    Before: GHC.Base.stimes
              TyArg [GHC.Types.Char]
              ValArg GHC.Base.$fSemigroup[] @ GHC.Types.Char
    After:  GHC.Base.$fSemigroup[]_$cstimes @ GHC.Types.Char
    Cont:   ApplyToTy GHC.Integer.Type.Integer
            ApplyToVal nodup GHC.Real.$fIntegralInteger
            ApplyToVal nodup 1000000
            ApplyToVal nodup (GHC.CString.unpackCString# "foo"#)
            Stop[RhsCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "foo"#
    After:  (\ (a_a7VD :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) -> GHC.CString.unpackFoldrCString# @ b_a7VH a_a7VD))
              "foo"#
    Cont:   Stop[BoringCtxt] [GHC.Types.Char]
Rule fired
    Rule: Class op >>
    Module: (BUILTIN)
    Before: GHC.Base.>> TyArg GHC.Types.IO ValArg GHC.Base.$fMonadIO
    After:  GHC.Base.$fApplicativeIO2
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <GHC.Types.IO a>_R
                    ->_R <GHC.Types.IO b>_R
                    ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                    :: (forall a b.
                        GHC.Types.IO a
                        -> GHC.Types.IO b
                        -> GHC.Prim.State# GHC.Prim.RealWorld
                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #))
                       ~R# (forall a b.
                            GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO b))
    Cont:   ApplyToTy ()
            ApplyToTy ()
            ApplyToVal nodup (Main.measure
                                @ GHC.Base.String
                                (Control.DeepSeq.$fNFData[]
                                   @ GHC.Types.Char Control.DeepSeq.$fNFDataChar)
                                (GHC.CString.unpackCString# "stimes : "#)
                                Main.testStimes)
            ApplyToVal nodup (GHC.Base.>>
                                @ GHC.Types.IO
                                GHC.Base.$fMonadIO
                                @ ()
                                @ ()
                                (Main.measure
                                   @ GHC.Types.Double
                                   Control.DeepSeq.$fNFDataDouble
                                   (GHC.CString.unpackCString# "fractional power 1 : "#)
                                   Main.testFractionalPower)
                                (GHC.Base.>>
                                   @ GHC.Types.IO
                                   GHC.Base.$fMonadIO
                                   @ ()
                                   @ ()
                                   (Main.measure
                                      @ GHC.Types.Double
                                      Control.DeepSeq.$fNFDataDouble
                                      (GHC.CString.unpackCString# "fractional power 2 : "#)
                                      Main.testFractionalPower)
                                   (GHC.Base.>>
                                      @ GHC.Types.IO
                                      GHC.Base.$fMonadIO
                                      @ ()
                                      @ ()
                                      (Main.measure
                                         @ GHC.Types.Double
                                         Control.DeepSeq.$fNFDataDouble
                                         (GHC.CString.unpackCString# "fractional power 3 : "#)
                                         Main.testFractionalPower)
                                      (Main.measure
                                         @ GHC.Integer.Type.Integer
                                         Control.DeepSeq.$fNFDataInteger
                                         (GHC.CString.unpackCString# "integral power : "#)
                                         Main.testIntegralPower))))
            Stop[RhsCtxt] GHC.Types.IO ()
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "stimes : "#
    After:  (\ (a_a7VD :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) -> GHC.CString.unpackFoldrCString# @ b_a7VH a_a7VD))
              "stimes : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op >>
    Module: (BUILTIN)
    Before: GHC.Base.>> TyArg GHC.Types.IO ValArg GHC.Base.$fMonadIO
    After:  GHC.Base.$fApplicativeIO2
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <GHC.Types.IO a>_R
                    ->_R <GHC.Types.IO b>_R
                    ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                    :: (forall a b.
                        GHC.Types.IO a
                        -> GHC.Types.IO b
                        -> GHC.Prim.State# GHC.Prim.RealWorld
                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #))
                       ~R# (forall a b.
                            GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO b))
    Cont:   ApplyToTy ()
            ApplyToTy ()
            ApplyToVal nodup (Main.measure
                                @ GHC.Types.Double
                                Control.DeepSeq.$fNFDataDouble
                                (GHC.CString.unpackCString# "fractional power 1 : "#)
                                Main.testFractionalPower)
            ApplyToVal nodup (GHC.Base.>>
                                @ GHC.Types.IO
                                GHC.Base.$fMonadIO
                                @ ()
                                @ ()
                                (Main.measure
                                   @ GHC.Types.Double
                                   Control.DeepSeq.$fNFDataDouble
                                   (GHC.CString.unpackCString# "fractional power 2 : "#)
                                   Main.testFractionalPower)
                                (GHC.Base.>>
                                   @ GHC.Types.IO
                                   GHC.Base.$fMonadIO
                                   @ ()
                                   @ ()
                                   (Main.measure
                                      @ GHC.Types.Double
                                      Control.DeepSeq.$fNFDataDouble
                                      (GHC.CString.unpackCString# "fractional power 3 : "#)
                                      Main.testFractionalPower)
                                   (Main.measure
                                      @ GHC.Integer.Type.Integer
                                      Control.DeepSeq.$fNFDataInteger
                                      (GHC.CString.unpackCString# "integral power : "#)
                                      Main.testIntegralPower)))
            CastIt (GHC.Types.N:IO[0] <()>_R
                    :: GHC.Types.IO ()
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)))
            ApplyToVal nodup ipv_a7YN
            Stop[BoringCtxt] (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "fractional power 1 : "#
    After:  (\ (a_a7VD :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) -> GHC.CString.unpackFoldrCString# @ b_a7VH a_a7VD))
              "fractional power 1 : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op >>
    Module: (BUILTIN)
    Before: GHC.Base.>> TyArg GHC.Types.IO ValArg GHC.Base.$fMonadIO
    After:  GHC.Base.$fApplicativeIO2
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <GHC.Types.IO a>_R
                    ->_R <GHC.Types.IO b>_R
                    ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                    :: (forall a b.
                        GHC.Types.IO a
                        -> GHC.Types.IO b
                        -> GHC.Prim.State# GHC.Prim.RealWorld
                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #))
                       ~R# (forall a b.
                            GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO b))
    Cont:   ApplyToTy ()
            ApplyToTy ()
            ApplyToVal nodup (Main.measure
                                @ GHC.Types.Double
                                Control.DeepSeq.$fNFDataDouble
                                (GHC.CString.unpackCString# "fractional power 2 : "#)
                                Main.testFractionalPower)
            ApplyToVal nodup (GHC.Base.>>
                                @ GHC.Types.IO
                                GHC.Base.$fMonadIO
                                @ ()
                                @ ()
                                (Main.measure
                                   @ GHC.Types.Double
                                   Control.DeepSeq.$fNFDataDouble
                                   (GHC.CString.unpackCString# "fractional power 3 : "#)
                                   Main.testFractionalPower)
                                (Main.measure
                                   @ GHC.Integer.Type.Integer
                                   Control.DeepSeq.$fNFDataInteger
                                   (GHC.CString.unpackCString# "integral power : "#)
                                   Main.testIntegralPower))
            CastIt (GHC.Types.N:IO[0] <()>_R
                    :: GHC.Types.IO ()
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)))
            ApplyToVal nodup ipv_a7YN
            Stop[BoringCtxt] (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "fractional power 2 : "#
    After:  (\ (a_a7VD :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) -> GHC.CString.unpackFoldrCString# @ b_a7VH a_a7VD))
              "fractional power 2 : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op >>
    Module: (BUILTIN)
    Before: GHC.Base.>> TyArg GHC.Types.IO ValArg GHC.Base.$fMonadIO
    After:  GHC.Base.$fApplicativeIO2
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <GHC.Types.IO a>_R
                    ->_R <GHC.Types.IO b>_R
                    ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                    :: (forall a b.
                        GHC.Types.IO a
                        -> GHC.Types.IO b
                        -> GHC.Prim.State# GHC.Prim.RealWorld
                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #))
                       ~R# (forall a b.
                            GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO b))
    Cont:   ApplyToTy ()
            ApplyToTy ()
            ApplyToVal nodup (Main.measure
                                @ GHC.Types.Double
                                Control.DeepSeq.$fNFDataDouble
                                (GHC.CString.unpackCString# "fractional power 3 : "#)
                                Main.testFractionalPower)
            ApplyToVal nodup (Main.measure
                                @ GHC.Integer.Type.Integer
                                Control.DeepSeq.$fNFDataInteger
                                (GHC.CString.unpackCString# "integral power : "#)
                                Main.testIntegralPower)
            CastIt (GHC.Types.N:IO[0] <()>_R
                    :: GHC.Types.IO ()
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)))
            ApplyToVal nodup ipv_a7YN
            Stop[BoringCtxt] (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "fractional power 3 : "#
    After:  (\ (a_a7VD :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) -> GHC.CString.unpackFoldrCString# @ b_a7VH a_a7VD))
              "fractional power 3 : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "integral power : "#
    After:  (\ (a_a7VD :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) -> GHC.CString.unpackFoldrCString# @ b_a7VH a_a7VD))
              "integral power : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op $p1Integral
    Module: (BUILTIN)
    Before: GHC.Real.$p1Integral
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fRealInteger
    Cont:   Stop[RhsCtxt] GHC.Real.Real GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Real
    Module: (BUILTIN)
    Before: GHC.Real.$p1Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Num.$fNumInteger
    Cont:   Stop[RhsCtxt] GHC.Num.Num GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8cs
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p2Real
    Module: (BUILTIN)
    Before: GHC.Real.$p2Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Integer.Type.$fOrdInteger
    Cont:   Stop[RhsCtxt] GHC.Classes.Ord GHC.Integer.Type.Integer
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Negative exponent"#
    After:  (\ (a_a7VD :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @ GHC.Types.Char
                 (\ (@ b_a7VH) -> GHC.CString.unpackFoldrCString# @ b_a7VH a_a7VD))
              "Negative exponent"#
    Cont:   StrictArg GHC.Err.errorWithoutStackTrace
            Stop[RhsCtxt] GHC.Types.Double
Rule fired
    Rule: Class op $p1Integral
    Module: (BUILTIN)
    Before: GHC.Real.$p1Integral
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fRealInteger
    Cont:   Stop[RhsCtxt] GHC.Real.Real GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Real
    Module: (BUILTIN)
    Before: GHC.Real.$p1Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Num.$fNumInteger
    Cont:   Stop[RhsCtxt] GHC.Num.Num GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8ca
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8c8
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8cc
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p2Real
    Module: (BUILTIN)
    Before: GHC.Real.$p2Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Integer.Type.$fOrdInteger
    Cont:   Stop[RhsCtxt] GHC.Classes.Ord GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Ord
    Module: (BUILTIN)
    Before: GHC.Classes.$p1Ord
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fOrdInteger
    After:  GHC.Integer.Type.$fEqInteger
    Cont:   Stop[RhsCtxt] GHC.Classes.Eq GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Integral
    Module: (BUILTIN)
    Before: GHC.Real.$p1Integral
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fRealInteger
    Cont:   Stop[RhsCtxt] GHC.Real.Real GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Real
    Module: (BUILTIN)
    Before: GHC.Real.$p1Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Num.$fNumInteger
    Cont:   Stop[RhsCtxt] GHC.Num.Num GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8ce
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8bW
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8cg
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p2Real
    Module: (BUILTIN)
    Before: GHC.Real.$p2Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Integer.Type.$fOrdInteger
    Cont:   Stop[RhsCtxt] GHC.Classes.Ord GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Ord
    Module: (BUILTIN)
    Before: GHC.Classes.$p1Ord
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fOrdInteger
    After:  GHC.Integer.Type.$fEqInteger
    Cont:   Stop[RhsCtxt] GHC.Classes.Eq GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Integral
    Module: (BUILTIN)
    Before: GHC.Real.$p1Integral
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fRealInteger
    Cont:   Stop[RhsCtxt] GHC.Real.Real GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Real
    Module: (BUILTIN)
    Before: GHC.Real.$p1Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Num.$fNumInteger
    Cont:   Stop[RhsCtxt] GHC.Num.Num GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8bK
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8bI
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p2Real
    Module: (BUILTIN)
    Before: GHC.Real.$p2Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Integer.Type.$fOrdInteger
    Cont:   Stop[RhsCtxt] GHC.Classes.Ord GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Ord
    Module: (BUILTIN)
    Before: GHC.Classes.$p1Ord
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fOrdInteger
    After:  GHC.Integer.Type.$fEqInteger
    Cont:   Stop[RhsCtxt] GHC.Classes.Eq GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Integral
    Module: (BUILTIN)
    Before: GHC.Real.$p1Integral
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fRealInteger
    Cont:   Stop[RhsCtxt] GHC.Real.Real GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Real
    Module: (BUILTIN)
    Before: GHC.Real.$p1Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Num.$fNumInteger
    Cont:   Stop[RhsCtxt] GHC.Num.Num GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8bw
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Num.$fNumInteger_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8by
            Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p2Real
    Module: (BUILTIN)
    Before: GHC.Real.$p2Real
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fRealInteger
    After:  GHC.Integer.Type.$fOrdInteger
    Cont:   Stop[RhsCtxt] GHC.Classes.Ord GHC.Integer.Type.Integer
Rule fired
    Rule: Class op $p1Ord
    Module: (BUILTIN)
    Before: GHC.Classes.$p1Ord
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fOrdInteger
    After:  GHC.Integer.Type.$fEqInteger
    Cont:   Stop[RhsCtxt] GHC.Classes.Eq GHC.Integer.Type.Integer
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fEqInteger
    After:  GHC.Integer.Type.eqInteger
    Cont:   ApplyToVal nodup (GHC.Real.rem
                                @ GHC.Integer.Type.Integer
                                GHC.Real.$fIntegralInteger
                                n_a8b3
                                lvl_s8bx)
            ApplyToVal nodup lvl_s8bz
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: Class op rem
    Module: (BUILTIN)
    Before: GHC.Real.rem
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fIntegralInteger_$crem
    Cont:   ApplyToVal nodup n_a8b3
            ApplyToVal nodup lvl_s8bx
            StrictArg GHC.Integer.Type.eqInteger#
            ApplyToVal nodup y_a8di
            Select nodup wild_a8dj
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: eqInteger#
    Module: (BUILTIN)
    Before: GHC.Integer.Type.eqInteger# ValArg lvl_s8bx ValArg 0
    After:  0#
    Cont:   Select nodup wild_a8dm
            StrictArg GHC.Integer.Type.eqInteger#
            ApplyToVal nodup y_a8di
            Select nodup wild_a8dj
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: Class op $p1Fractional
    Module: (BUILTIN)
    Before: GHC.Real.$p1Fractional
              TyArg GHC.Types.Double ValArg GHC.Float.$fFractionalDouble
    After:  GHC.Float.$fNumDouble
    Cont:   Stop[RhsCtxt] GHC.Num.Num GHC.Types.Double
Rule fired
    Rule: SPEC/Main even @ Integer
    Module: (Main)
    Before: GHC.Real.even
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  (\ ($dIntegral_s8b7
                  :: GHC.Real.Integral GHC.Integer.Type.Integer) ->
               $seven_s8b8)
              GHC.Real.$fIntegralInteger
    Cont:   ApplyToVal nodup y1_a7SG
            Select nodup wild4_a7SI
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fEqInteger
    After:  GHC.Integer.Type.eqInteger
    Cont:   ApplyToVal nodup y1_a7SG
            ApplyToVal nodup lvl_s8c9
            Select nodup wild5_a7SL
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op *
    Module: (BUILTIN)
    Before: GHC.Num.*
              TyArg GHC.Types.Double ValArg GHC.Float.$fNumDouble
    After:  GHC.Float.timesDouble
    Cont:   ApplyToVal nodup x1_a7SF
            ApplyToVal nodup x1_a7SF
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op quot
    Module: (BUILTIN)
    Before: GHC.Real.quot
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fIntegralInteger_$cquot
    Cont:   ApplyToVal nodup y1_a7SG
            ApplyToVal nodup lvl_s8cb
            Stop[BoringCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: eqInteger#
    Module: (BUILTIN)
    Before: GHC.Integer.Type.eqInteger# ValArg lvl_s8cb ValArg 0
    After:  0#
    Cont:   Select nodup wild_a8dN
            Stop[BoringCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op *
    Module: (BUILTIN)
    Before: GHC.Num.*
              TyArg GHC.Types.Double ValArg GHC.Float.$fNumDouble
    After:  GHC.Float.timesDouble
    Cont:   ApplyToVal nodup x1_a7SF
            ApplyToVal nodup z_a7SH
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op *
    Module: (BUILTIN)
    Before: GHC.Num.*
              TyArg GHC.Types.Double ValArg GHC.Float.$fNumDouble
    After:  GHC.Float.timesDouble
    Cont:   ApplyToVal nodup x1_a7SF
            ApplyToVal nodup z_a7SH
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op *
    Module: (BUILTIN)
    Before: GHC.Num.*
              TyArg GHC.Types.Double ValArg GHC.Float.$fNumDouble
    After:  GHC.Float.timesDouble
    Cont:   ApplyToVal nodup x1_a7SF
            ApplyToVal nodup x1_a7SF
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op quot
    Module: (BUILTIN)
    Before: GHC.Real.quot
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fIntegralInteger_$cquot
    Cont:   ApplyToVal nodup y1_a7SG
            ApplyToVal nodup lvl_s8cd
            Stop[BoringCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: eqInteger#
    Module: (BUILTIN)
    Before: GHC.Integer.Type.eqInteger# ValArg lvl_s8cd ValArg 0
    After:  0#
    Cont:   Select nodup wild_a8dN
            Stop[BoringCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: SPEC/Main even @ Integer
    Module: (Main)
    Before: GHC.Real.even
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  (\ ($dIntegral_s8b7
                  :: GHC.Real.Integral GHC.Integer.Type.Integer) ->
               $seven_s8b8)
              GHC.Real.$fIntegralInteger
    Cont:   ApplyToVal nodup y_a7Sr
            Select nodup wild2_a7Su
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fEqInteger
    After:  GHC.Integer.Type.eqInteger
    Cont:   ApplyToVal nodup y_a7Sr
            ApplyToVal nodup lvl_s8bX
            Select nodup wild3_a7Sx
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op *
    Module: (BUILTIN)
    Before: GHC.Num.*
              TyArg GHC.Types.Double ValArg GHC.Float.$fNumDouble
    After:  GHC.Float.timesDouble
    Cont:   ApplyToVal nodup x_a7Sq
            ApplyToVal nodup x_a7Sq
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op quot
    Module: (BUILTIN)
    Before: GHC.Real.quot
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fIntegralInteger_$cquot
    Cont:   ApplyToVal nodup y_a7Sr
            ApplyToVal nodup lvl_s8cf
            Stop[BoringCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: eqInteger#
    Module: (BUILTIN)
    Before: GHC.Integer.Type.eqInteger# ValArg lvl_s8cf ValArg 0
    After:  0#
    Cont:   Select nodup wild_a8dN
            Stop[BoringCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op *
    Module: (BUILTIN)
    Before: GHC.Num.*
              TyArg GHC.Types.Double ValArg GHC.Float.$fNumDouble
    After:  GHC.Float.timesDouble
    Cont:   ApplyToVal nodup x_a7Sq
            ApplyToVal nodup x_a7Sq
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op quot
    Module: (BUILTIN)
    Before: GHC.Real.quot
              TyArg GHC.Integer.Type.Integer ValArg GHC.Real.$fIntegralInteger
    After:  GHC.Real.$fIntegralInteger_$cquot
    Cont:   ApplyToVal nodup y_a7Sr
            ApplyToVal nodup lvl_s8ch
            Stop[BoringCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: eqInteger#
    Module: (BUILTIN)
    Before: GHC.Integer.Type.eqInteger# ValArg lvl_s8ch ValArg 0
    After:  0#
    Cont:   Select nodup wild_a8dN
            Stop[BoringCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: Class op fromInteger
    Module: (BUILTIN)
    Before: GHC.Num.fromInteger
              TyArg GHC.Types.Double ValArg GHC.Float.$fNumDouble
    After:  GHC.Float.$fNumDouble_$cfromInteger
    Cont:   ApplyToVal nodup lvl_s8ci
            Stop[RhsCtxt] GHC.Types.Double
Rule fired
    Rule: doubleFromInteger
    Module: (BUILTIN)
    Before: GHC.Integer.Type.doubleFromInteger ValArg 1
    After:  1.0##
    Cont:   Select nodup wild_a8dX
            Stop[RhsCtxt] GHC.Types.Double
Rule fired
    Rule: Class op <
    Module: (BUILTIN)
    Before: GHC.Classes.<
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fOrdInteger
    After:  GHC.Integer.Type.ltInteger
    Cont:   ApplyToVal nodup y0_a7Se
            ApplyToVal nodup lvl_s8bJ
            Select nodup wild_a7Sf
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fEqInteger
    After:  GHC.Integer.Type.eqInteger
    Cont:   ApplyToVal nodup y0_a7Se
            ApplyToVal nodup lvl_s8bL
            Select nodup wild1_a7Si
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op >=
    Module: (BUILTIN)
    Before: GHC.Classes.>=
              TyArg GHC.Integer.Type.Integer ValArg GHC.Integer.Type.$fOrdInteger
    After:  GHC.Integer.Type.geInteger
    Cont:   ApplyToVal nodup n_a7RY
            ApplyToVal nodup lvl_s8ct
            Select nodup wild_a7RZ
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op recip
    Module: (BUILTIN)
    Before: GHC.Real.recip
              TyArg GHC.Types.Double ValArg GHC.Float.$fFractionalDouble
    After:  GHC.Float.$fFractionalDouble_$crecip
    Cont:   ApplyToVal nodup (GHC.Real.^
                                @ GHC.Types.Double
                                @ GHC.Integer.Type.Integer
                                $dNum1_s8an
                                GHC.Real.$fIntegralInteger
                                x_a7RX
                                (GHC.Num.negate @ GHC.Integer.Type.Integer $dNum_s8cp n_a7RY))
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: Class op negate
    Module: (BUILTIN)
    Before: GHC.Num.negate
              TyArg GHC.Integer.Type.Integer ValArg GHC.Num.$fNumInteger
    After:  GHC.Integer.Type.negateInteger
    Cont:   ApplyToVal nodup n_a7RY
            Stop[RuleArgCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: SPEC measure @ String
    Module: (Main)
    Before: measure_s7WY
              TyArg GHC.Base.String
              ValArg (\ (eta_X81P :: [GHC.Types.Char]) -> go_s8cP eta_X81P)
                     `cast` (Sym (Control.DeepSeq.N:NFData[0] <[GHC.Types.Char]>_N)
                             :: ([GHC.Types.Char] -> ())
                                ~R# Control.DeepSeq.NFData [GHC.Types.Char])
    After:  (\ ($dNFData_X8ap
                  :: Control.DeepSeq.NFData GHC.Base.String) ->
               $smeasure_s8ac)
              ((\ (eta_X81P :: [GHC.Types.Char]) -> go_s8cP eta_X81P)
               `cast` (Sym (Control.DeepSeq.N:NFData[0] <[GHC.Types.Char]>_N)
                       :: ([GHC.Types.Char] -> ())
                          ~R# Control.DeepSeq.NFData [GHC.Types.Char]))
    Cont:   ApplyToVal nodup lvl_s8cT
            ApplyToVal nodup Main.testStimes
            ApplyToVal nodup s_a7YK
            Select nodup ds1_a7YL
            Stop[BoringCtxt] (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
Rule fired
    Rule: SPEC measure @ Double
    Module: (Main)
    Before: measure_s7WY
              TyArg GHC.Types.Double
              ValArg (Control.DeepSeq.rwhnf @ GHC.Types.Double)
                     `cast` (Sym (Control.DeepSeq.N:NFData[0] <GHC.Types.Double>_N)
                             :: (GHC.Types.Double -> ())
                                ~R# Control.DeepSeq.NFData GHC.Types.Double)
    After:  (\ ($dNFData_s8a5
                  :: Control.DeepSeq.NFData GHC.Types.Double) ->
               $smeasure_s8a6)
              ((Control.DeepSeq.rwhnf @ GHC.Types.Double)
               `cast` (Sym (Control.DeepSeq.N:NFData[0] <GHC.Types.Double>_N)
                       :: (GHC.Types.Double -> ())
                          ~R# Control.DeepSeq.NFData GHC.Types.Double))
    Cont:   ApplyToVal nodup lvl_s8cW
            ApplyToVal nodup Main.testFractionalPower
            ApplyToVal nodup ipv_a7YN
            Select nodup ds1_X7Zb
            Stop[BoringCtxt] (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
Rule fired
    Rule: SPEC measure @ Double
    Module: (Main)
    Before: measure_s7WY
              TyArg GHC.Types.Double
              ValArg (Control.DeepSeq.rwhnf @ GHC.Types.Double)
                     `cast` (Sym (Control.DeepSeq.N:NFData[0] <GHC.Types.Double>_N)
                             :: (GHC.Types.Double -> ())
                                ~R# Control.DeepSeq.NFData GHC.Types.Double)
    After:  (\ ($dNFData_s8a5
                  :: Control.DeepSeq.NFData GHC.Types.Double) ->
               $smeasure_s8a6)
              ((Control.DeepSeq.rwhnf @ GHC.Types.Double)
               `cast` (Sym (Control.DeepSeq.N:NFData[0] <GHC.Types.Double>_N)
                       :: (GHC.Types.Double -> ())
                          ~R# Control.DeepSeq.NFData GHC.Types.Double))
    Cont:   ApplyToVal nodup lvl_s8cZ
            ApplyToVal nodup Main.testFractionalPower
            ApplyToVal nodup ipv_X7Zf
            Select nodup ds1_X7Zg
            Stop[BoringCtxt] (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
Rule fired
    Rule: SPEC measure @ Double
    Module: (Main)
    Before: measure_s7WY
              TyArg GHC.Types.Double
              ValArg (Control.DeepSeq.rwhnf @ GHC.Types.Double)
                     `cast` (Sym (Control.DeepSeq.N:NFData[0] <GHC.Types.Double>_N)
                             :: (GHC.Types.Double -> ())
                                ~R# Control.DeepSeq.NFData GHC.Types.Double)
    After:  (\ ($dNFData_s8a5
                  :: Control.DeepSeq.NFData GHC.Types.Double) ->
               $smeasure_s8a6)
              ((Control.DeepSeq.rwhnf @ GHC.Types.Double)
               `cast` (Sym (Control.DeepSeq.N:NFData[0] <GHC.Types.Double>_N)
                       :: (GHC.Types.Double -> ())
                          ~R# Control.DeepSeq.NFData GHC.Types.Double))
    Cont:   ApplyToVal nodup lvl_s8d2
            ApplyToVal nodup Main.testFractionalPower
            ApplyToVal nodup ipv_X7Zk
            Select nodup ds1_X7Zl
            Stop[BoringCtxt] (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
Rule fired
    Rule: SPEC measure @ Integer
    Module: (Main)
    Before: measure_s7WY
              TyArg GHC.Integer.Type.Integer
              ValArg (Control.DeepSeq.rwhnf @ GHC.Integer.Type.Integer)
                     `cast` (Sym (Control.DeepSeq.N:NFData[0]
                                      <GHC.Integer.Type.Integer>_N)
                             :: (GHC.Integer.Type.Integer -> ())
                                ~R# Control.DeepSeq.NFData GHC.Integer.Type.Integer)
    After:  (\ ($dNFData_s8a1
                  :: Control.DeepSeq.NFData GHC.Integer.Type.Integer) ->
               $smeasure_s8a2)
              ((Control.DeepSeq.rwhnf @ GHC.Integer.Type.Integer)
               `cast` (Sym (Control.DeepSeq.N:NFData[0]
                                <GHC.Integer.Type.Integer>_N)
                       :: (GHC.Integer.Type.Integer -> ())
                          ~R# Control.DeepSeq.NFData GHC.Integer.Type.Integer))
    Cont:   ApplyToVal nodup lvl_s8d5
            ApplyToVal nodup Main.testIntegralPower
            ApplyToVal nodup ipv_X7Zp
            Stop[BoringCtxt] (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Negative exponent"#
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              "Negative exponent"#
    Cont:   StrictArg GHC.Err.errorWithoutStackTrace
            Stop[RhsCtxt] GHC.Types.Double
Rule fired
    Rule: SPEC/Main ^ @ Double @ Integer
    Module: (Main)
    Before: GHC.Real.^
              TyArg GHC.Types.Double
              TyArg GHC.Integer.Type.Integer
              ValArg GHC.Float.$fNumDouble
              ValArg GHC.Real.$fIntegralInteger
              ValArg x_a7RX
              ValArg GHC.Integer.Type.negateInteger n_a7RY
    After:  (\ ($dIntegral_s8at
                  :: GHC.Real.Integral GHC.Integer.Type.Integer)
               ($dNum_s8as :: GHC.Num.Num GHC.Types.Double) ->
               $s^_s8au)
              GHC.Real.$fIntegralInteger GHC.Float.$fNumDouble
    Cont:   Select nodup wild_a8ed
            Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: SPEC/Main ^ @ Double @ Integer
    Module: (Main)
    Before: GHC.Real.^
              TyArg GHC.Types.Double
              TyArg GHC.Integer.Type.Integer
              ValArg GHC.Float.$fNumDouble
              ValArg GHC.Real.$fIntegralInteger
              ValArg x_a7RX
              ValArg n_a7RY
    After:  (\ ($dIntegral_s8at
                  :: GHC.Real.Integral GHC.Integer.Type.Integer)
               ($dNum_s8as :: GHC.Num.Num GHC.Types.Double) ->
               $s^_s8au)
              GHC.Real.$fIntegralInteger GHC.Float.$fNumDouble
    Cont:   Stop[BoringCtxt] GHC.Types.Double
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg lvl_s8cv
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              lvl_s8cv
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.CString.unpackCString# lvl_s8cv
              ValArg GHC.Types.: @ GHC.Types.Char ww3_X7X5 ww4_X7X7
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char (GHC.CString.unpackCString# lvl_s8cv)
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: SC:++0
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Types.: @ GHC.Types.Char ww3_X7X5 ww4_X7X7
              ValArg GHC.CString.unpackCString# lvl_s8cv
    After:  (\ (@ b_a7UT)
               (sc_a7UU :: [b_a7UT])
               (sc1_a7UV :: b_a7UT)
               (sc2_a7UW :: [b_a7UT]) ->
               GHC.Base.++_$s++ @ b_a7UT sc_a7UU sc1_a7UV sc2_a7UW)
              @ GHC.Types.Char
              (GHC.CString.unpackCString# lvl_s8cv)
              ww3_X7X5
              ww4_X7X7
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack-append
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg lvl_s8cu
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg case GHC.Show.$w$cshowsPrec4
                            0# duration_s8ae (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_X7X5, ww4_X7X7 #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackCString# lvl_s8cv)
                       ww3_X7X5
                       ww4_X7X7
                     }
    After:  (\ (a_a7VN :: GHC.Prim.Addr#)
               (n_a7VO :: [GHC.Types.Char]) ->
               GHC.CString.unpackAppendCString# a_a7VN n_a7VO)
              lvl_s8cu
              (case GHC.Show.$w$cshowsPrec4
                      0# duration_s8ae (GHC.Types.[] @ GHC.Types.Char)
               of
               { (# ww3_X7X5, ww4_X7X7 #) ->
               GHC.Base.++_$s++
                 @ GHC.Types.Char
                 (GHC.CString.unpackCString# lvl_s8cv)
                 ww3_X7X5
                 ww4_X7X7
               })
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.CString.unpackAppendCString#
                       lvl_s8cu
                       (case GHC.Show.$w$cshowsPrec4
                               0# duration_s8ae (GHC.Types.[] @ GHC.Types.Char)
                        of
                        { (# ww3_X7X5, ww4_X7X7 #) ->
                        GHC.Base.++_$s++
                          @ GHC.Types.Char
                          (GHC.CString.unpackCString# lvl_s8cv)
                          ww3_X7X5
                          ww4_X7X7
                        })
              ValArg GHC.Types.: @ GHC.Types.Char ww3_a7Vp ww4_a7Vq
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char
              (GHC.CString.unpackAppendCString#
                 lvl_s8cu
                 (case GHC.Show.$w$cshowsPrec4
                         0# duration_s8ae (GHC.Types.[] @ GHC.Types.Char)
                  of
                  { (# ww3_X7X5, ww4_X7X7 #) ->
                  GHC.Base.++_$s++
                    @ GHC.Types.Char
                    (GHC.CString.unpackCString# lvl_s8cv)
                    ww3_X7X5
                    ww4_X7X7
                  }))
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: SC:++0
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Types.: @ GHC.Types.Char ww3_a7Vp ww4_a7Vq
              ValArg GHC.CString.unpackAppendCString#
                       lvl_s8cu
                       (case GHC.Show.$w$cshowsPrec4
                               0# duration_s8ae (GHC.Types.[] @ GHC.Types.Char)
                        of
                        { (# ww3_X7X5, ww4_X7X7 #) ->
                        GHC.Base.++_$s++
                          @ GHC.Types.Char
                          (GHC.CString.unpackCString# lvl_s8cv)
                          ww3_X7X5
                          ww4_X7X7
                        })
    After:  (\ (@ b_a7UT)
               (sc_a7UU :: [b_a7UT])
               (sc1_a7UV :: b_a7UT)
               (sc2_a7UW :: [b_a7UT]) ->
               GHC.Base.++_$s++ @ b_a7UT sc_a7UU sc1_a7UV sc2_a7UW)
              @ GHC.Types.Char
              (GHC.CString.unpackAppendCString#
                 lvl_s8cu
                 (case GHC.Show.$w$cshowsPrec4
                         0# duration_s8ae (GHC.Types.[] @ GHC.Types.Char)
                  of
                  { (# ww3_X7X5, ww4_X7X7 #) ->
                  GHC.Base.++_$s++
                    @ GHC.Types.Char
                    (GHC.CString.unpackCString# lvl_s8cv)
                    ww3_X7X5
                    ww4_X7X7
                  }))
              ww3_a7Vp
              ww4_a7Vq
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg case GHC.Show.$w$cshowsPrec4
                            0#
                            (GHC.Integer.Type.divInteger duration_s8ae lvl_s8cw)
                            (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_a7Vp, ww4_a7Vq #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackAppendCString#
                          lvl_s8cu
                          (case GHC.Show.$w$cshowsPrec4
                                  0# duration_s8ae (GHC.Types.[] @ GHC.Types.Char)
                           of
                           { (# ww3_X7X5, ww4_X7X7 #) ->
                           GHC.Base.++_$s++
                             @ GHC.Types.Char
                             (GHC.CString.unpackCString# lvl_s8cv)
                             ww3_X7X5
                             ww4_X7X7
                           }))
                       ww3_a7Vp
                       ww4_a7Vq
                     }
              ValArg description_a1UB
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char
              (case GHC.Show.$w$cshowsPrec4
                      0#
                      (GHC.Integer.Type.divInteger duration_s8ae lvl_s8cw)
                      (GHC.Types.[] @ GHC.Types.Char)
               of
               { (# ww3_a7Vp, ww4_a7Vq #) ->
               GHC.Base.++_$s++
                 @ GHC.Types.Char
                 (GHC.CString.unpackAppendCString#
                    lvl_s8cu
                    (case GHC.Show.$w$cshowsPrec4
                            0# duration_s8ae (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_X7X5, ww4_X7X7 #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackCString# lvl_s8cv)
                       ww3_X7X5
                       ww4_X7X7
                     }))
                 ww3_a7Vp
                 ww4_a7Vq
               })
    Cont:   StrictArg GHC.Show.showLitString
            ApplyToVal nodup GHC.Show.$fShow[]1
            Stop[BoringCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg lvl_s8cy
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              lvl_s8cy
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.CString.unpackCString# lvl_s8cy
              ValArg GHC.Types.: @ GHC.Types.Char ww3_X7Xb ww4_X7Xd
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char (GHC.CString.unpackCString# lvl_s8cy)
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: SC:++0
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Types.: @ GHC.Types.Char ww3_X7Xb ww4_X7Xd
              ValArg GHC.CString.unpackCString# lvl_s8cy
    After:  (\ (@ b_a7UT)
               (sc_a7UU :: [b_a7UT])
               (sc1_a7UV :: b_a7UT)
               (sc2_a7UW :: [b_a7UT]) ->
               GHC.Base.++_$s++ @ b_a7UT sc_a7UU sc1_a7UV sc2_a7UW)
              @ GHC.Types.Char
              (GHC.CString.unpackCString# lvl_s8cy)
              ww3_X7Xb
              ww4_X7Xd
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack-append
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg lvl_s8cx
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg case GHC.Show.$w$cshowsPrec4
                            0# duration_s8a8 (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_X7Xb, ww4_X7Xd #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackCString# lvl_s8cy)
                       ww3_X7Xb
                       ww4_X7Xd
                     }
    After:  (\ (a_a7VN :: GHC.Prim.Addr#)
               (n_a7VO :: [GHC.Types.Char]) ->
               GHC.CString.unpackAppendCString# a_a7VN n_a7VO)
              lvl_s8cx
              (case GHC.Show.$w$cshowsPrec4
                      0# duration_s8a8 (GHC.Types.[] @ GHC.Types.Char)
               of
               { (# ww3_X7Xb, ww4_X7Xd #) ->
               GHC.Base.++_$s++
                 @ GHC.Types.Char
                 (GHC.CString.unpackCString# lvl_s8cy)
                 ww3_X7Xb
                 ww4_X7Xd
               })
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.CString.unpackAppendCString#
                       lvl_s8cx
                       (case GHC.Show.$w$cshowsPrec4
                               0# duration_s8a8 (GHC.Types.[] @ GHC.Types.Char)
                        of
                        { (# ww3_X7Xb, ww4_X7Xd #) ->
                        GHC.Base.++_$s++
                          @ GHC.Types.Char
                          (GHC.CString.unpackCString# lvl_s8cy)
                          ww3_X7Xb
                          ww4_X7Xd
                        })
              ValArg GHC.Types.: @ GHC.Types.Char ww3_a7Vp ww4_a7Vq
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char
              (GHC.CString.unpackAppendCString#
                 lvl_s8cx
                 (case GHC.Show.$w$cshowsPrec4
                         0# duration_s8a8 (GHC.Types.[] @ GHC.Types.Char)
                  of
                  { (# ww3_X7Xb, ww4_X7Xd #) ->
                  GHC.Base.++_$s++
                    @ GHC.Types.Char
                    (GHC.CString.unpackCString# lvl_s8cy)
                    ww3_X7Xb
                    ww4_X7Xd
                  }))
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: SC:++0
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Types.: @ GHC.Types.Char ww3_a7Vp ww4_a7Vq
              ValArg GHC.CString.unpackAppendCString#
                       lvl_s8cx
                       (case GHC.Show.$w$cshowsPrec4
                               0# duration_s8a8 (GHC.Types.[] @ GHC.Types.Char)
                        of
                        { (# ww3_X7Xb, ww4_X7Xd #) ->
                        GHC.Base.++_$s++
                          @ GHC.Types.Char
                          (GHC.CString.unpackCString# lvl_s8cy)
                          ww3_X7Xb
                          ww4_X7Xd
                        })
    After:  (\ (@ b_a7UT)
               (sc_a7UU :: [b_a7UT])
               (sc1_a7UV :: b_a7UT)
               (sc2_a7UW :: [b_a7UT]) ->
               GHC.Base.++_$s++ @ b_a7UT sc_a7UU sc1_a7UV sc2_a7UW)
              @ GHC.Types.Char
              (GHC.CString.unpackAppendCString#
                 lvl_s8cx
                 (case GHC.Show.$w$cshowsPrec4
                         0# duration_s8a8 (GHC.Types.[] @ GHC.Types.Char)
                  of
                  { (# ww3_X7Xb, ww4_X7Xd #) ->
                  GHC.Base.++_$s++
                    @ GHC.Types.Char
                    (GHC.CString.unpackCString# lvl_s8cy)
                    ww3_X7Xb
                    ww4_X7Xd
                  }))
              ww3_a7Vp
              ww4_a7Vq
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg case GHC.Show.$w$cshowsPrec4
                            0#
                            (GHC.Integer.Type.divInteger duration_s8a8 lvl_s8cz)
                            (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_a7Vp, ww4_a7Vq #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackAppendCString#
                          lvl_s8cx
                          (case GHC.Show.$w$cshowsPrec4
                                  0# duration_s8a8 (GHC.Types.[] @ GHC.Types.Char)
                           of
                           { (# ww3_X7Xb, ww4_X7Xd #) ->
                           GHC.Base.++_$s++
                             @ GHC.Types.Char
                             (GHC.CString.unpackCString# lvl_s8cy)
                             ww3_X7Xb
                             ww4_X7Xd
                           }))
                       ww3_a7Vp
                       ww4_a7Vq
                     }
              ValArg description_a1UB
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char
              (case GHC.Show.$w$cshowsPrec4
                      0#
                      (GHC.Integer.Type.divInteger duration_s8a8 lvl_s8cz)
                      (GHC.Types.[] @ GHC.Types.Char)
               of
               { (# ww3_a7Vp, ww4_a7Vq #) ->
               GHC.Base.++_$s++
                 @ GHC.Types.Char
                 (GHC.CString.unpackAppendCString#
                    lvl_s8cx
                    (case GHC.Show.$w$cshowsPrec4
                            0# duration_s8a8 (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_X7Xb, ww4_X7Xd #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackCString# lvl_s8cy)
                       ww3_X7Xb
                       ww4_X7Xd
                     }))
                 ww3_a7Vp
                 ww4_a7Vq
               })
    Cont:   StrictArg GHC.Show.showLitString
            ApplyToVal nodup GHC.Show.$fShow[]1
            Stop[BoringCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg lvl_s8cB
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              lvl_s8cB
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.CString.unpackCString# lvl_s8cB
              ValArg GHC.Types.: @ GHC.Types.Char ww3_X7Xd ww4_X7Xf
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char (GHC.CString.unpackCString# lvl_s8cB)
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: SC:++0
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Types.: @ GHC.Types.Char ww3_X7Xd ww4_X7Xf
              ValArg GHC.CString.unpackCString# lvl_s8cB
    After:  (\ (@ b_a7UT)
               (sc_a7UU :: [b_a7UT])
               (sc1_a7UV :: b_a7UT)
               (sc2_a7UW :: [b_a7UT]) ->
               GHC.Base.++_$s++ @ b_a7UT sc_a7UU sc1_a7UV sc2_a7UW)
              @ GHC.Types.Char
              (GHC.CString.unpackCString# lvl_s8cB)
              ww3_X7Xd
              ww4_X7Xf
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack-append
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg lvl_s8cA
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg case GHC.Show.$w$cshowsPrec4
                            0# duration_s8a4 (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_X7Xd, ww4_X7Xf #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackCString# lvl_s8cB)
                       ww3_X7Xd
                       ww4_X7Xf
                     }
    After:  (\ (a_a7VN :: GHC.Prim.Addr#)
               (n_a7VO :: [GHC.Types.Char]) ->
               GHC.CString.unpackAppendCString# a_a7VN n_a7VO)
              lvl_s8cA
              (case GHC.Show.$w$cshowsPrec4
                      0# duration_s8a4 (GHC.Types.[] @ GHC.Types.Char)
               of
               { (# ww3_X7Xd, ww4_X7Xf #) ->
               GHC.Base.++_$s++
                 @ GHC.Types.Char
                 (GHC.CString.unpackCString# lvl_s8cB)
                 ww3_X7Xd
                 ww4_X7Xf
               })
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.CString.unpackAppendCString#
                       lvl_s8cA
                       (case GHC.Show.$w$cshowsPrec4
                               0# duration_s8a4 (GHC.Types.[] @ GHC.Types.Char)
                        of
                        { (# ww3_X7Xd, ww4_X7Xf #) ->
                        GHC.Base.++_$s++
                          @ GHC.Types.Char
                          (GHC.CString.unpackCString# lvl_s8cB)
                          ww3_X7Xd
                          ww4_X7Xf
                        })
              ValArg GHC.Types.: @ GHC.Types.Char ww3_a7Vp ww4_a7Vq
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char
              (GHC.CString.unpackAppendCString#
                 lvl_s8cA
                 (case GHC.Show.$w$cshowsPrec4
                         0# duration_s8a4 (GHC.Types.[] @ GHC.Types.Char)
                  of
                  { (# ww3_X7Xd, ww4_X7Xf #) ->
                  GHC.Base.++_$s++
                    @ GHC.Types.Char
                    (GHC.CString.unpackCString# lvl_s8cB)
                    ww3_X7Xd
                    ww4_X7Xf
                  }))
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: SC:++0
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Types.: @ GHC.Types.Char ww3_a7Vp ww4_a7Vq
              ValArg GHC.CString.unpackAppendCString#
                       lvl_s8cA
                       (case GHC.Show.$w$cshowsPrec4
                               0# duration_s8a4 (GHC.Types.[] @ GHC.Types.Char)
                        of
                        { (# ww3_X7Xd, ww4_X7Xf #) ->
                        GHC.Base.++_$s++
                          @ GHC.Types.Char
                          (GHC.CString.unpackCString# lvl_s8cB)
                          ww3_X7Xd
                          ww4_X7Xf
                        })
    After:  (\ (@ b_a7UT)
               (sc_a7UU :: [b_a7UT])
               (sc1_a7UV :: b_a7UT)
               (sc2_a7UW :: [b_a7UT]) ->
               GHC.Base.++_$s++ @ b_a7UT sc_a7UU sc1_a7UV sc2_a7UW)
              @ GHC.Types.Char
              (GHC.CString.unpackAppendCString#
                 lvl_s8cA
                 (case GHC.Show.$w$cshowsPrec4
                         0# duration_s8a4 (GHC.Types.[] @ GHC.Types.Char)
                  of
                  { (# ww3_X7Xd, ww4_X7Xf #) ->
                  GHC.Base.++_$s++
                    @ GHC.Types.Char
                    (GHC.CString.unpackCString# lvl_s8cB)
                    ww3_X7Xd
                    ww4_X7Xf
                  }))
              ww3_a7Vp
              ww4_a7Vq
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg case GHC.Show.$w$cshowsPrec4
                            0#
                            (GHC.Integer.Type.divInteger duration_s8a4 lvl_s8cC)
                            (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_a7Vp, ww4_a7Vq #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackAppendCString#
                          lvl_s8cA
                          (case GHC.Show.$w$cshowsPrec4
                                  0# duration_s8a4 (GHC.Types.[] @ GHC.Types.Char)
                           of
                           { (# ww3_X7Xd, ww4_X7Xf #) ->
                           GHC.Base.++_$s++
                             @ GHC.Types.Char
                             (GHC.CString.unpackCString# lvl_s8cB)
                             ww3_X7Xd
                             ww4_X7Xf
                           }))
                       ww3_a7Vp
                       ww4_a7Vq
                     }
              ValArg description_a1UB
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char
              (case GHC.Show.$w$cshowsPrec4
                      0#
                      (GHC.Integer.Type.divInteger duration_s8a4 lvl_s8cC)
                      (GHC.Types.[] @ GHC.Types.Char)
               of
               { (# ww3_a7Vp, ww4_a7Vq #) ->
               GHC.Base.++_$s++
                 @ GHC.Types.Char
                 (GHC.CString.unpackAppendCString#
                    lvl_s8cA
                    (case GHC.Show.$w$cshowsPrec4
                            0# duration_s8a4 (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_X7Xd, ww4_X7Xf #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackCString# lvl_s8cB)
                       ww3_X7Xd
                       ww4_X7Xf
                     }))
                 ww3_a7Vp
                 ww4_a7Vq
               })
    Cont:   StrictArg GHC.Show.showLitString
            ApplyToVal nodup GHC.Show.$fShow[]1
            Stop[BoringCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg lvl_s8cE
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              lvl_s8cE
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.CString.unpackCString# lvl_s8cE
              ValArg GHC.Types.: @ GHC.Types.Char ww3_X7Xk ww4_X7Xm
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char (GHC.CString.unpackCString# lvl_s8cE)
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: SC:++0
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Types.: @ GHC.Types.Char ww3_X7Xk ww4_X7Xm
              ValArg GHC.CString.unpackCString# lvl_s8cE
    After:  (\ (@ b_a7UT)
               (sc_a7UU :: [b_a7UT])
               (sc1_a7UV :: b_a7UT)
               (sc2_a7UW :: [b_a7UT]) ->
               GHC.Base.++_$s++ @ b_a7UT sc_a7UU sc1_a7UV sc2_a7UW)
              @ GHC.Types.Char
              (GHC.CString.unpackCString# lvl_s8cE)
              ww3_X7Xk
              ww4_X7Xm
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack-append
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg lvl_s8cD
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg case GHC.Show.$w$cshowsPrec4
                            0# duration_s8a0 (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_X7Xk, ww4_X7Xm #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackCString# lvl_s8cE)
                       ww3_X7Xk
                       ww4_X7Xm
                     }
    After:  (\ (a_a7VN :: GHC.Prim.Addr#)
               (n_a7VO :: [GHC.Types.Char]) ->
               GHC.CString.unpackAppendCString# a_a7VN n_a7VO)
              lvl_s8cD
              (case GHC.Show.$w$cshowsPrec4
                      0# duration_s8a0 (GHC.Types.[] @ GHC.Types.Char)
               of
               { (# ww3_X7Xk, ww4_X7Xm #) ->
               GHC.Base.++_$s++
                 @ GHC.Types.Char
                 (GHC.CString.unpackCString# lvl_s8cE)
                 ww3_X7Xk
                 ww4_X7Xm
               })
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.CString.unpackAppendCString#
                       lvl_s8cD
                       (case GHC.Show.$w$cshowsPrec4
                               0# duration_s8a0 (GHC.Types.[] @ GHC.Types.Char)
                        of
                        { (# ww3_X7Xk, ww4_X7Xm #) ->
                        GHC.Base.++_$s++
                          @ GHC.Types.Char
                          (GHC.CString.unpackCString# lvl_s8cE)
                          ww3_X7Xk
                          ww4_X7Xm
                        })
              ValArg GHC.Types.: @ GHC.Types.Char ww3_a7Vp ww4_a7Vq
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char
              (GHC.CString.unpackAppendCString#
                 lvl_s8cD
                 (case GHC.Show.$w$cshowsPrec4
                         0# duration_s8a0 (GHC.Types.[] @ GHC.Types.Char)
                  of
                  { (# ww3_X7Xk, ww4_X7Xm #) ->
                  GHC.Base.++_$s++
                    @ GHC.Types.Char
                    (GHC.CString.unpackCString# lvl_s8cE)
                    ww3_X7Xk
                    ww4_X7Xm
                  }))
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: SC:++0
    Module: (GHC.Base)
    Before: GHC.Base.++
              TyArg GHC.Types.Char
              ValArg GHC.Types.: @ GHC.Types.Char ww3_a7Vp ww4_a7Vq
              ValArg GHC.CString.unpackAppendCString#
                       lvl_s8cD
                       (case GHC.Show.$w$cshowsPrec4
                               0# duration_s8a0 (GHC.Types.[] @ GHC.Types.Char)
                        of
                        { (# ww3_X7Xk, ww4_X7Xm #) ->
                        GHC.Base.++_$s++
                          @ GHC.Types.Char
                          (GHC.CString.unpackCString# lvl_s8cE)
                          ww3_X7Xk
                          ww4_X7Xm
                        })
    After:  (\ (@ b_a7UT)
               (sc_a7UU :: [b_a7UT])
               (sc1_a7UV :: b_a7UT)
               (sc2_a7UW :: [b_a7UT]) ->
               GHC.Base.++_$s++ @ b_a7UT sc_a7UU sc1_a7UV sc2_a7UW)
              @ GHC.Types.Char
              (GHC.CString.unpackAppendCString#
                 lvl_s8cD
                 (case GHC.Show.$w$cshowsPrec4
                         0# duration_s8a0 (GHC.Types.[] @ GHC.Types.Char)
                  of
                  { (# ww3_X7Xk, ww4_X7Xm #) ->
                  GHC.Base.++_$s++
                    @ GHC.Types.Char
                    (GHC.CString.unpackCString# lvl_s8cE)
                    ww3_X7Xk
                    ww4_X7Xm
                  }))
              ww3_a7Vp
              ww4_a7Vq
    Cont:   Stop[RuleArgCtxt] [GHC.Types.Char]
Rule fired
    Rule: foldr/app
    Module: (GHC.Base)
    Before: GHC.Base.foldr
              TyArg GHC.Types.Char
              TyArg [GHC.Types.Char]
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg case GHC.Show.$w$cshowsPrec4
                            0#
                            (GHC.Integer.Type.divInteger duration_s8a0 lvl_s8cF)
                            (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_a7Vp, ww4_a7Vq #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackAppendCString#
                          lvl_s8cD
                          (case GHC.Show.$w$cshowsPrec4
                                  0# duration_s8a0 (GHC.Types.[] @ GHC.Types.Char)
                           of
                           { (# ww3_X7Xk, ww4_X7Xm #) ->
                           GHC.Base.++_$s++
                             @ GHC.Types.Char
                             (GHC.CString.unpackCString# lvl_s8cE)
                             ww3_X7Xk
                             ww4_X7Xm
                           }))
                       ww3_a7Vp
                       ww4_a7Vq
                     }
              ValArg description_a1UB
    After:  (\ (@ a_a7WP)
               (ys_a7WQ :: [a_a7WP])
               (xs_a7WR [Occ=Once] :: [a_a7WP]) ->
               GHC.Base.++ @ a_a7WP xs_a7WR ys_a7WQ)
              @ GHC.Types.Char
              (case GHC.Show.$w$cshowsPrec4
                      0#
                      (GHC.Integer.Type.divInteger duration_s8a0 lvl_s8cF)
                      (GHC.Types.[] @ GHC.Types.Char)
               of
               { (# ww3_a7Vp, ww4_a7Vq #) ->
               GHC.Base.++_$s++
                 @ GHC.Types.Char
                 (GHC.CString.unpackAppendCString#
                    lvl_s8cD
                    (case GHC.Show.$w$cshowsPrec4
                            0# duration_s8a0 (GHC.Types.[] @ GHC.Types.Char)
                     of
                     { (# ww3_X7Xk, ww4_X7Xm #) ->
                     GHC.Base.++_$s++
                       @ GHC.Types.Char
                       (GHC.CString.unpackCString# lvl_s8cE)
                       ww3_X7Xk
                       ww4_X7Xm
                     }))
                 ww3_a7Vp
                 ww4_a7Vq
               })
    Cont:   StrictArg GHC.Show.showLitString
            ApplyToVal nodup GHC.Show.$fShow[]1
            Stop[BoringCtxt] [GHC.Types.Char]
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "foo"#
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              "foo"#
    Cont:   Stop[BoringCtxt] [GHC.Types.Char]
Rule fired
    Rule: SPEC ^
    Module: (GHC.Real)
    Before: GHC.Real.^
              TyArg GHC.Integer.Type.Integer
              TyArg GHC.Integer.Type.Integer
              ValArg GHC.Num.$fNumInteger
              ValArg GHC.Real.$fIntegralInteger
              ValArg 3
              ValArg 1000000
    After:  (\ ($dIntegral_a7Yk
                  :: GHC.Real.Integral GHC.Integer.Type.Integer)
               ($dNum_a7Yl :: GHC.Num.Num GHC.Integer.Type.Integer) ->
               GHC.Real.^_$s^)
              GHC.Real.$fIntegralInteger GHC.Num.$fNumInteger
    Cont:   Stop[RhsCtxt] GHC.Integer.Type.Integer
Rule fired
    Rule: SPEC/Main ^^ @ Double @ Integer
    Module: (Main)
    Before: GHC.Real.^^
              TyArg GHC.Types.Double
              TyArg GHC.Integer.Type.Integer
              ValArg GHC.Float.$fFractionalDouble
              ValArg GHC.Real.$fIntegralInteger
    After:  (\ ($dIntegral_s8ah
                  :: GHC.Real.Integral GHC.Integer.Type.Integer)
               ($dFractional_s8ag :: GHC.Real.Fractional GHC.Types.Double) ->
               $s^^_s8ai)
              GHC.Real.$fIntegralInteger GHC.Float.$fFractionalDouble
    Cont:   ApplyToVal nodup (GHC.Types.D# 5.0##)
            ApplyToVal nodup 441
            Stop[RhsCtxt] GHC.Types.Double
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "stimes : "#
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              "stimes : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "fractional power 1 : "#
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              "fractional power 1 : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "fractional power 2 : "#
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              "fractional power 2 : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "fractional power 3 : "#
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              "fractional power 3 : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "integral power : "#
              ValArg GHC.Types.: @ GHC.Types.Char
              ValArg GHC.Types.[] @ GHC.Types.Char
    After:  (\ (a_a7VM :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_a7VM)
              "integral power : "#
    Cont:   Stop[BoringCtxt] GHC.Base.String
